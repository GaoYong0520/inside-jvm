GC回收：
    (参考blog:
        https://www.cnblogs.com/xiaoxi/p/6486852.html
        https://www.cnblogs.com/sunshisonghit/p/6694590.html)
    1.如何确定一个“垃圾”？
        引用计数法：Java对象的访问是通过引用来实现的，要是没有任何引用指向一个对象，说明该对象失去了所有引用，被回收（Python就是这样实现的，但是无法解决
                    循环引用，比如：
                        MyObj o1 = new MyObj();
                        MyObj o2 = new MyObj();
                        o1.obj = o2;
                        o2.obj = o1;
                        o1 = null;
                        o2 =null;
                        虽然o1和o2已经失去了所有引用，但是仍然存在循环引用，无法实现回收）
        可达路径法：
            这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何
            引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。

            那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：
            (1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
            (2). 方法区中的类静态属性引用的对象。
            (3). 方法区中常量引用的对象。
            (4). 本地方法栈中JNI(Native方法)引用的对象。

            ----------------------------------
            |           GCROOTs              |
            ---------------|------------------
                           |
                           obj
                           |  \
                         obj1  obj2       obj3---obj4(无可达路径，即使循环引用也回收)



        对于可达性分析算法而言，未到达的对象并非是“非死不可”的，若要宣判一个对象死亡，至少需要经历两次标记阶段。

        1. 如果对象在进行可达性分析后发现没有与GCRoots相连的引用链，则该对象被第一次标记并进行一次筛选，
            筛选条件为是否有必要执行该对象的finalize方法，若对象没有覆盖finalize方法或者该finalize方法是否已经被虚拟机执行过了，
            则均视作不必要执行该对象的finalize方法，即该对象将会被回收。反之，若对象覆盖了finalize方法并且该finalize方法并没有
            被执行过，那么，这个对象会被放置在一个叫F-Queue的队列中，之后会由虚拟机自动建立的、优先级低的Finalizer线程去执行，
            而虚拟机不必要等待该线程执行结束，即虚拟机只负责建立线程，其他的事情交给此线程去处理。

        2.对F-Queue中对象进行第二次标记，如果对象在finalize方法中拯救了自己，即关联上了GCRoots引用链，如把this关键字赋值给其他变
        量，那么在第二次标记的时候该对象将从“即将回收”的集合中移除，如果对象还是没有拯救自己，那就会被回收。如下代码演示了一个对象
        如何在finalize方法中拯救了自己，然而，它只能拯救自己一次，第二次就被回收了。

        常见的将对象判定为可回收对象的情况：
         1）显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象，比如下面的代码：
         Object obj = new Object();
         obj = null;
         Object obj1 = new Object();
         Object obj2 = new Object();
         obj1 = obj2;
         2）局部引用所指向的对象，比如下面这段代码：
         void fun() {

         .....
             for(int i=0;i<10;i++) {
                 Object obj = new Object();
                 System.out.println(obj.getClass());
             }
         }
         循环每执行完一次，生成的Object对象都会成为可回收的对象。

         3）只有弱引用与其关联的对象，比如：
         WeakReference<String> wr = new WeakReference<String>(new String("world"));
    2.四种引用
        1、强引用

        代码中普遍存在的类似"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

        2、软引用

        描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有
        足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。

        3、弱引用

        描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱
        引用关联的对象。Java中的类WeakReference表示弱引用。

        4、虚引用

        这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类
        PhantomReference表示虚引用。

    3.典型的垃圾回收算法
        方法区垃圾回收的对象：
            方法区的垃圾回收主要回收两部分内容：1. 废弃常量。2. 无用的类。
            ？？？如何判断废弃常量呢？
                以字面量回收为例，如果一个字符串“abc”已经进入常量池，但是当前系统没有任何一个String对象引用了
            叫做“abc”的字面量，那么，如果发生垃圾回收并且有必要时，“abc”就会被系统移出常量池。常量池中的其
            他类（接口）、方法、字段的符号引用也与此类似。

            ？？如何判断无用的类呢？需要满足以下三个条件

            <1>.该类的所有实例都已经被回收，即Java堆中不存在该类的任何实例。
            <2>.加载该类的ClassLoader已经被回收。
            <3>.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
            满足以上三个条件的类可以进行垃圾回收，但是并不是无用就被回收，虚拟机提供了一些参数供我们配置。

        1.标记-清除（Mark-Sweep）算法
             这是最基础的算法，标记-清除算法就如同它的名字样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后
             统一回收所有被标记的对象。这种算法的不足主要体现在效率和空间，从效率的角度讲，标记和清除两个过程的效率都不高；从空间的
             角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到
             足够的连续内存而不得不提前触发一次垃圾收集动作。

        2.复制算法
                 是为了解决效率问题而出现的，它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外
             一块上面，然后再把已经使用过的内存空间一次性清理掉。这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎
             片等复杂情况，只需要移动指针，按照顺序分配即可。
                不过这种算法有个缺点，内存缩小为了原来的一半，这样代价太高了。现在的商用虚拟机都采用这种算法来回收新生代，不过研究表明
             1:1的比例非常不科学，因此新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survi
             vor。每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Surv
             ivor空间。HotSpot虚拟机默认Eden区和Survivor区的比例为8:1，意思是每次新生代中可用内存空间为整个新生代容量的90%。
             当然，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代进行分配担保
             （Handle Promotion）。

        3、标记-整理（Mark-Compact）算法
                复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。
            老年代都是不易被回收的对象，对象存活率高，因此一般不能直接选用复制算法。根据老年代的特点，有人提出了另外一种标记-整理算
            法，过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外
            的内存



    4.java中新生代老生代:
        HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下
        来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，
        将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。

        因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为
        两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

        在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象
        都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:
        MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区
        已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。
        不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有
        对象移动到年老代中。


    5.一个对象的一辈子：
        我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的
        人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在
        Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，
        并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。

    6.有关年轻代的JVM参数

      1)-XX:NewSize和-XX:MaxNewSize

      用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。

      2)-XX:SurvivorRatio

      用于设置Eden和其中一个Survivor的比值，这个值也比较重要。

      3)-XX:+PrintTenuringDistribution

      这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。

      4).-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold

      用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1

    7.垃圾收集器：

        Serial      ParNew    Parallel Scavenge
          |    \  /  |        /          |
          |     \/   |       /           |              G1
          |  ___/\   |      /            |
        CMS /____Serial Old      Parallel Old

        (连线的表示可以搭配使用)
        Serial:采用复制算法的单线程的收集器，单线程一方面意味着它只会使用一个CPU或一条线程去完成垃圾收集工作，另一方面也意味着它进
                行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。---运行在Client模式下的默认新生代收集器。
                说明：1. 需要STW（Stop The World），停顿时间长。
                      2. 简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。

        ParNew:---Server模式下的虚拟机首选的新生代收集器,其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为
               和Serial收集器完全一样。新生代采用复制算法，年老代采用标记-整理算法


        Parallel Scavenge:一个新生代收集器，也是用复制算法的收集器，也是并行的多线程收集器，但是它的特点是它的关注点和其他收集器
               不同。介绍这个收集器主要还是介绍吞吐量的概念。CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel
                Scavenge收集器的目标则是打到一个可控制的吞吐量。所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，
                即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。
                另外，Parallel Scavenge收集器是---虚拟机运行在Server模式下的默认垃圾收集器。

        Serial Old:Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理算法”，这个收集器的主要意义也是在于给Client
                模式下的虚拟机使用。

        Parallel Old:Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK 1.6之后的出现，“吞吐量优先
                收集器”终于了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+
                Parallel Old收集器的组合

        CMS:以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法，收集过程分为如下四步：
            (1). 初始标记，标记GCRoots能直接关联到的对象，时间很短。
            (2). 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。
            (3). 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。
            (4). 并发清除，回收内存空间，时间很长。
            其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行

        G1:G1收集器有以下特点：
           (1). 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。
           (2). 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更
                好的收集效果。
           (3). 空间整合。基于标记 - 整理算法，无内存碎片产生。
           (4). 可预测的停顿。能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间
                不得超过N毫秒。
              在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他
           收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生
           代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合